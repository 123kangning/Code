工作记录

# practice_page

## 智能体Demo开发

### 类型定义

```go
type ChatReq struct {
    SessionID string `json:"session_id" binding:"required"`
    IsInit    bool   `json:"is_init"`
    Messages  string `json:"messages"`
}
//流式返回结构体
type ChatRespData struct {
    Content string `json:"content"`
    IsQ     bool   `json:"is_q"`
}
```
### 流式从chan接收，用SSE机制推送给前端

```go
type chatHandler struct{}


func (chat *chatHandler) Chat(c *gin.Context) {
    chatReq := &define.ChatReq{}
    if err := c.ShouldBindJSON(chatReq); err != nil {
       xlog.Error(c, fmt.Sprintf("ChatHandler.Chat,bind json err=%v", err))
       c.JSON(http.StatusBadRequest, common.Error(c, common.ERROR_PARAM))
       return
    }
    if chatReq.SessionID == "" {
       //第一次访问
       chatReq.SessionID = util.GenUUID()
       fmt.Println("chatReq.SessionID", chatReq.SessionID)
    }
    ch, err := api.NewChatService().Chat(c, chatReq)
    if err != nil {
       xlog.Error(c, fmt.Sprintf("ChatHandler.Chat err=%v", err))
       c.JSON(http.StatusInternalServerError, common.Error(c, common.ERROR_INTER))
       return
    }
    returnByStream(c, ch)
}


func returnByStream(c *gin.Context, ch <-chan *define.ChatRespData) {
    c.Header("Content-Type", "text/event-stream")
    buf := bytes.NewBuffer(nil)
    c.Stream(func(w io.Writer) bool {
       data, notClose := <-ch
       if !notClose {
          return false
       }
       if data.IsQ {
          buf.WriteString(data.Content)
          data.Content = buf.String()
       }
       //之前没有加换行，导致没有默认刷新，现在加上换行
       _, err := fmt.Fprintln(w, util.Json(data))
       if err != nil {
          // 表示当前stream中断，关闭stream流式传输逻辑
          return false
       }
       // return true 表示stream正常传输，下一次继续写
       return true
    })
}


```
### 流式从算法接收，写入chan

```go
func PostMultipartFormDataStream(chatReq *ChatReq) (io.ReadCloser, error) {
    host := viper.GetString("algo.host")
    path := "/alg-server/tab/get_chat"
    url := host + path


    reqBody, err := json.Marshal(chatReq)
    if err != nil {
       xlog.Error(nil, fmt.Sprintf("adapter.PostMultipartFormDataStream,json.Marshal err=%v", err))
       return nil, err
    }


    client := &http.Client{}
    request, err := http.NewRequest("POST", url, bytes.NewBuffer(reqBody))
    if err != nil {
       xlog.Error(nil, fmt.Sprintf("adapter.PostMultipartFormDataStream,http.NewRequest err=%v", err))
       return nil, err
    }
    request.Header.Set("Content-Type", "application/json")


    resp, err := client.Do(request)
    if err != nil {
       xlog.Error(nil, fmt.Sprintf("adapter.PostMultipartFormDataStream,client.Do err=%v", err))
       return nil, err
    }
    // 可以根据业务需求更细致地处理不同状态码的情况，这里先简单返回错误提示
    if resp.StatusCode < http.StatusOK || resp.StatusCode >= http.StatusMultipleChoices {
       xlog.Error(nil, fmt.Sprintf("adapter.PostMultipartFormDataStream,resp.StatusCode=%d", resp.StatusCode))
       return nil, fmt.Errorf("request failed with status code: %d", resp.StatusCode)
    }
    return resp.Body, nil
}


func ChatWithAlgo(c *gin.Context, chatReq *ChatReq) (<-chan *define.ChatRespData, error) {
    // 发送POST请求
    respBody, err := PostMultipartFormDataStream(chatReq)
    if err != nil {
       xlog.Error(c, fmt.Sprintf("adapter.ChatWithAlgo,util.Request err=%v", err))
       return nil, err
    }
    //defer respBody.Close()
    //fmt.Println(io.ReadAll(respBody))
    ch := make(chan *define.ChatRespData, 100)
    scanner := bufio.NewScanner(respBody)
    go func() {
       for scanner.Scan() {
          data := &define.ChatRespData{}
          err = util.JsonUnmarshal(scanner.Bytes(), data)
          if err != nil {
             xlog.Error(c, fmt.Sprintf("adapter.ChatWithAlgo,util.JsonUnmarshal err=%v", err))
             continue
          }
          ch <- data
       }
       xlog.Info(c, "adapter.ChatWithAlgo close(ch)")
       close(ch)
    }()
    return ch, nil
}


```
### 测试接口

```bash
curl --location --request GET 'http://localhost:80/v1/api/ai/refresh' \
--header 'Cookie: wx=df9813f23a8bd4fd943f98c073bd2055mymyxyxbbq; xesId=eb4db07dd4b0ce9b17c7c0c390cce42c; prelogid=9e6c0d367902d54e3c6889f0f0e05bc9; tal_token=tal173aLsCFlymxX1jSfZsD6fQplbjyuDXR1EyZN7qeam9-uwp25o1unkK0_TsWcNys14g_4FJs4WTC4IzECZBsVYaMvjgBRuGRkzKrspFKbzlW7penyRauAAjqlFG9MkhGeYztwmuFPKJ4ZNyDhfUxuy4T0cH4n2419gYEgKvK-emQ18mkI2y3C4JPl4OM3N4GlmyX1TCVrD-XiDbZtNwu_RuNPTFOIpL9Zv0CEXmq4EpQ8W2pJzr5VeGxByg2pSwHSbpauMQAzIQSzaJW3vs_XqKtRPMUM-DMCt0avUrTB8fdIPjg; tal_token=tal173V3bcvzaw3i0QVnYADbwD-tFXblX7YLt6UI0y8Wfq3MeY13Umfluzr7mYAzRlzBMQ1yjROWWkxUOsV1r8CFLJHde8Ykww93ZDam3P4xAHlQqsz59uYtyTpKRO6FPrXCxpKI_XchP7zlzUWqqjjpaHGjwUD8UGeTS11g8BwOqvRoomkI2y3C4JPl4OM3N4GlmyX1TCVrD-XiDbZtNwu_RuNPTFOIpL9Zv0CEXmq4EpQ8W2pJzr5VeGxByg2pSwHSbpauMQAzIQSzaJW3vs_XqKtRPMUM-DMCt0avUrTB8fdIPjg' \
--header 'User-Agent: Apifox/1.0.0 (https://apifox.com)' \
--header 'Accept: */*' \
--header 'Host: localhost:80' \
--header 'Connection: keep-alive' \
--header 'ContentType: text/event-stream'


curl --location --request POST 'http://localhost:80/v1/api/ai/chat' \
--header 'Cookie: wx=df9813f23a8bd4fd943f98c073bd2055mymyxyxbbq; xesId=eb4db07dd4b0ce9b17c7c0c390cce42c; prelogid=9e6c0d367902d54e3c6889f0f0e05bc9; tal_token=tal173aLsCFlymxX1jSfZsD6fQplbjyuDXR1EyZN7qeam9-uwp25o1unkK0_TsWcNys14g_4FJs4WTC4IzECZBsVYaMvjgBRuGRkzKrspFKbzlW7penyRauAAjqlFG9MkhGeYztwmuFPKJ4ZNyDhfUxuy4T0cH4n2419gYEgKvK-emQ18mkI2y3C4JPl4OM3N4GlmyX1TCVrD-XiDbZtNwu_RuNPTFOIpL9Zv0CEXmq4EpQ8W2pJzr5VeGxByg2pSwHSbpauMQAzIQSzaJW3vs_XqKtRPMUM-DMCt0avUrTB8fdIPjg' \
--header 'Content-Type: application/json' \
--data-raw '{
    "session_id": "1b7b97d5b71d42129fca297573ae9a71",
    "is_init": false,
    "messages": "简要说一下依赖注入"
}'
```
# practice物理实验

## 总览

### 文档

[https://yach-doc-shimo.zhiyinlou.com/docs/aBAYVo0YYvs6rO3j/](https://yach-doc-shimo.zhiyinlou.com/docs/aBAYVo0YYvs6rO3j/) 《初中物理实验工具》

[https://yach-doc-shimo.zhiyinlou.com/docs/A8xzYFWbHOcuqCIX/](https://yach-doc-shimo.zhiyinlou.com/docs/A8xzYFWbHOcuqCIX/) 《物理实验技术方案》

### 数据库

* run起来了项目

* 看了获取用户作答列表的接口，从上到下串了一遍

* 明天来把各个数据库表的关系联系起来

```sql
show create table xw_lab_paper;# 试卷信息，实验中每次作答都会生成一份新的试卷。关联实验name，学生ID
show create table xw_lab_info_list;# 模块和实验关联的中间表。关联年级ID，学科ID，模块ID，实验ID
show create table xw_lab_feedback;# 实验中具体问题的反馈。关联年级ID，学科ID，学生ID，问题ID
show create table xw_lab_paper_answer_detail;# 以指定试卷中的单个问题为单位，记录学生作答情况。关联科目ID，学生ID，试卷ID，问题ID
show create table xw_lab_paper_answer_record;# 以整张试卷为单位，记录学生作答情况。关联学生ID，科目ID，试卷ID
show create table xw_lab_paper_question;# 试卷和问题关联的中间表。关联试卷ID，问题ID
show create table xw_lab_question_detail;# 每个问题的具体详情，与试卷无关。无任何关联
```
### 代码

#### 代码结构

* internal

   * request：额外加的request结构体，可加可不加

   * handler：对接router的应用层

   * service：核心业务逻辑层，上接handler，下接biz

   * biz：数据库repo接口

   * data：数据库操作

#### 持久化操作

* 检验接口实现的小技巧

```sql
语法检查阶段确认repo方法是否都被实现
var _ biz.LabInfoListRepo = (*labInfoListRepo)(nil)
```
* 操作接口设计

   * 依赖注入：repo由外部实现，在usecase初始化时传入。mock时也很方便，直接实现这个接口，捏一堆返回值就可以暂时代替实际的db操作。

   * 多层抽象：usecase被上层调用，内部再调用repo，降低耦合度。

```plain
type LabPaperRepo interface {
    SaveStuPaper(ctx context.Context, sp []LabPaper) ([]LabPaper, error)
    UpdateStuPaper(ctx context.Context, values interface{}, options ...DBOption) error
    MGetStuPaper(ctx context.Context, options ...DBOption) ([]*LabPaper, error)
    GetStuPaper(ctx context.Context, options ...DBOption) (*LabPaper, error)
}
type LabPaperUsecase struct {
    repo LabPaperRepo
}
func (uc *LabPaperUsecase) SaveStuPaper(ctx context.Context, sp []LabPaper) ([]LabPaper, error) {
    xlog.Ix(ctx, "syncpracapi,"+util.GetFuncName(), "SaveStuPaper  %+v", sp)
    return uc.repo.SaveStuPaper(ctx, sp)
}
```
## 分发试卷时，题目是如何组织的？

1. 典题练习

2. 立即练习

   1. 知识点即是题目

      1. 所有知识点（题目）中随机挑出三道，组装成该学生本次答题的试卷

   2. 知识点非题目

      1. 通过当前组装试卷的参数，调用算法团队接口，获取试题。之后我们再把试题组装成试卷，维护连接关系并保存起来。

## 算法根据知识点推题的逻辑？

## 问题表中有stem（问题）和analytic（解析）字段，原数据是从哪里来的？

将知识点id列表发送给算法部门，算法返回这些知识点对应的题目。我们本地再将获取的题目保存到自己的数据库。

## ~~试卷答到一半，中途退出，如何找到之前作答的试卷？不需要支持~~

* ~~做答进度以及做答记录是否需要保存？~~


# culture项目

### 即时算法（Instant Algorithm）

* 当添加列操作指定`algorithm = instant`时，对于某些类型的表（例如 InnoDB 表），MySQL 会尝试使用即时算法来添加列。这种算法的主要特点是它可以在非常短的时间内完成列的添加操作，几乎是瞬间完成，对表的锁定时间极短，甚至可以在不阻塞其他对该表的读写操作的情况下完成列的添加。

## 给原来语文听写模块的提交接口做适配

* app端逻辑：

   * 通过提交拍照上传写字情况，app后端通过算法部门提供的OCR接口识别图片中文字内容，结合传递过去的正确答案，判断学生写的是否正确

* 小程序端逻辑：

   * 不进行拍照（加上拍照判题，工作量稍大，故取消），默认学生写的都对。学生写完之后，多个字都会展示出来，用户进行自查。

   * 前端在原来的基础上，加上一个correctType区分自己判断和OCR判断

   * app修改：correctType设置为1，表示拍照进行OCR判断。

   * 小程序适配·：correctType设置为2，用户自己判断，默认写的都对。

   * DB加一个判题类型的字段：correct_type。

```plain
alter table t_culture_chinese_answer_log add column `correct_type` tinyint NOT NULL DEFAULT 1 COMMENT '判题类型，1-OCR判题，2-用户自己判题';
```
* t_culture_chianese_answer_record中_ai_result字段中存储的链接是什么？看上去可用户上传的图片是一样的。

# tikuapi

## 通过希望学素养app的token登录希望学app

* 素养对应culture项目，希望学对应tikuapi。

目前，素养app登录的token与希望学主体的token鉴权是分开的。~~我们希望做一个类单点登录系统，希望学作为登录主体，素养app对接希望学app。~~我们目前是想让素养的用户跨app到希望学上课，所以让这两个系统token互联，但是我们不能直接做一个单点登录系统，让所有素养用户都通过希望学app登录。因为这两个app面向的用户、提供的服务都是不同的，素养用户可能不愿意再额外下载一个希望学app。

~~先看看代码，再做进一步设计。~~亚杰设计好了，直接借鉴。

* 看看common_libs中的usercenter用法，直接调就可以

### 测试方案

1. 原来希望学的用户，使用token能正常访问/拒绝。不影响原来功能。

2. 素养的用户，带着token能正常访问希望学的接口。

### 希望学token逻辑

#### 校验token逻辑

* internal/middleware/token.go：校验token，tal_token正确才放行

* internal/middleware/get_stuid.go：校验token，统一放行，只是尝试填充一下user_id

* 如果签名验证成功，说明 JWT 在传输过程中没有被篡改，并且确实是由拥有对应私钥的服务器生成的。

#### 签发token逻辑

* JWT 通常是使用私钥进行签名，公钥验证签名。签名的目的是保证数据的完整性和不可否认性。

### 素养token逻辑

与希望学基本一致

### 总结

配置switch，方便切换host


# 爬虫

## 反爬虫

* 未登录的重定向到登录页面，有手动点的验证码

   * 加入临时cookie解决

* html内容和显示的不一样，内容上反扒

   * 加入user-agent未解决

   * 初步排除，应该是通过 JavaScript 动态加载，导致无法简单地爬下来，尝试解决中

# 述职

top100之后的用户排名，保存在哪里？zset中吗？


学习记录

# polarDB和MySQL

* 用的是polarDB分布式版本，存算分离架构设计

[https://help.aliyun.com/zh/polardb/product-overview/](https://help.aliyun.com/zh/polardb/product-overview/)

组里用的是polarDB，和MySQL高度兼容，所以在基础使用上直接无缝切换。

but，polarDB作为一个分布式数据库，和MySQL的单机还是有区别的。数据分散到多个节点。

## 分布式存储的逻辑

### 计算节点

全局云数据服务：提供分布式的元数据，提供全局授时服务（TSO），维护Table/Schema、Statistic等Meta信息、维护账号、权限等安全信息。

解析器，优化器，执行器，

### 存储节点

## 分布式事务的保证

## 分布式查询需要注意的点

### 出现慢查询如何排查

慢查询示例：[https://yach-doc-shimo.zhiyinlou.com/sheets/gXqme7mXv4SebQqo/Mzsz9/](https://yach-doc-shimo.zhiyinlou.com/sheets/gXqme7mXv4SebQqo/Mzsz9/) 《2024-11-13慢查询专项治理》

慢查询优化建议：[https://yach-doc-shimo.zhiyinlou.com/docs/5xkGMQLmJ6SP6m3X/](https://yach-doc-shimo.zhiyinlou.com/docs/5xkGMQLmJ6SP6m3X/) 


# ETCD

## key存储/变更原理

## BultDB存储

## MVCC

## 迷你事务

## 日志与快照

